--- bme680copy.c	2019-10-17 22:14:39.000000000 +0100
+++ bme680.c	2019-10-17 22:09:54.000000000 +0100
@@ -48,7 +48,12 @@
 /*! @file bme680.c
  @brief Sensor driver for BME680 sensor */
 #include "bme680.h"
+#include <stdio.h>
+#include <stdlib.h>
 
+extern uint8_t coeff_array[BME680_COEFF_SIZE];
+
+void parseCSv();
 /*!
  * @brief This internal API is used to read the calibrated data from the sensor.
  *
@@ -64,7 +69,7 @@
  * @return Result of API execution status.
  * @retval zero -> Success / +ve value -> Warning / -ve value -> Error
  */
-static int8_t get_calib_data(struct bme680_dev *dev);
+ int8_t get_calib_data(struct bme680_dev *dev);
 
 /*!
  * @brief This internal API is used to set the gas configuration of the sensor.
@@ -74,7 +79,7 @@
  * @return Result of API execution status.
  * @retval zero -> Success / +ve value -> Warning / -ve value -> Error
  */
-static int8_t set_gas_config(struct bme680_dev *dev);
+ int8_t set_gas_config(struct bme680_dev *dev);
 
 /*!
  * @brief This internal API is used to get the gas configuration of the sensor.
@@ -86,7 +91,7 @@
  * @return Result of API execution status.
  * @retval zero -> Success / +ve value -> Warning / -ve value -> Error
  */
-static int8_t get_gas_config(struct bme680_dev *dev);
+ int8_t get_gas_config(struct bme680_dev *dev);
 
 /*!
  * @brief This internal API is used to calculate the Heat duration value.
@@ -95,63 +100,10 @@
  *
  * @return uint8_t threshold duration after calculation.
  */
-static uint8_t calc_heater_dur(uint16_t dur);
-
-#ifndef BME680_FLOAT_POINT_COMPENSATION
-
-/*!
- * @brief This internal API is used to calculate the temperature value.
- *
- * @param[in] dev	:Structure instance of bme680_dev.
- * @param[in] temp_adc	:Contains the temperature ADC value .
- *
- * @return uint32_t calculated temperature.
- */
-static int16_t calc_temperature(uint32_t temp_adc, struct bme680_dev *dev);
-
-/*!
- * @brief This internal API is used to calculate the pressure value.
- *
- * @param[in] dev	:Structure instance of bme680_dev.
- * @param[in] pres_adc	:Contains the pressure ADC value .
- *
- * @return uint32_t calculated pressure.
- */
-static uint32_t calc_pressure(uint32_t pres_adc, const struct bme680_dev *dev);
-
-/*!
- * @brief This internal API is used to calculate the humidity value.
- *
- * @param[in] dev	:Structure instance of bme680_dev.
- * @param[in] hum_adc	:Contains the humidity ADC value.
- *
- * @return uint32_t calculated humidity.
- */
-static uint32_t calc_humidity(uint16_t hum_adc, const struct bme680_dev *dev);
+ uint8_t calc_heater_dur(uint16_t dur);
 
-/*!
- * @brief This internal API is used to calculate the Gas Resistance value.
- *
- * @param[in] dev		:Structure instance of bme680_dev.
- * @param[in] gas_res_adc	:Contains the Gas Resistance ADC value.
- * @param[in] gas_range		:Contains the range of gas values.
- *
- * @return uint32_t calculated gas resistance.
- */
-static uint32_t calc_gas_resistance(uint16_t gas_res_adc, uint8_t gas_range, const struct bme680_dev *dev);
 
 /*!
- * @brief This internal API is used to calculate the Heat Resistance value.
- *
- * @param[in] dev	: Structure instance of bme680_dev
- * @param[in] temp	: Contains the target temperature value.
- *
- * @return uint8_t calculated heater resistance.
- */
-static uint8_t calc_heater_res(uint16_t temp, const struct bme680_dev *dev);
-
-#else
-/*!
  * @brief This internal API is used to calculate the
  * temperature value value in float format
  *
@@ -160,7 +112,7 @@
  *
  * @return Calculated temperature in float
  */
-static float calc_temperature(uint32_t temp_adc, struct bme680_dev *dev);
+ float calc_temperature(uint32_t temp_adc, struct bme680_dev *dev);
 
 /*!
  * @brief This internal API is used to calculate the
@@ -171,7 +123,7 @@
  *
  * @return Calculated pressure in float.
  */
-static float calc_pressure(uint32_t pres_adc, const struct bme680_dev *dev);
+ float calc_pressure(uint32_t pres_adc, const struct bme680_dev *dev);
 
 /*!
  * @brief This internal API is used to calculate the
@@ -182,7 +134,7 @@
  *
  * @return Calculated humidity in float.
  */
-static float calc_humidity(uint16_t hum_adc, const struct bme680_dev *dev);
+ float calc_humidity(uint16_t hum_adc, const struct bme680_dev *dev);
 
 /*!
  * @brief This internal API is used to calculate the
@@ -194,7 +146,7 @@
  *
  * @return Calculated gas resistance in float.
  */
-static float calc_gas_resistance(uint16_t gas_res_adc, uint8_t gas_range, const struct bme680_dev *dev);
+ float calc_gas_resistance(uint16_t gas_res_adc, uint8_t gas_range, const struct bme680_dev *dev);
 
 /*!
  * @brief This internal API is used to calculate the
@@ -205,9 +157,8 @@
  *
  * @return Calculated heater resistance in float.
  */
-static float calc_heater_res(uint16_t temp, const struct bme680_dev *dev);
+ float calc_heater_res(uint16_t temp, const struct bme680_dev *dev);
 
-#endif
 
 /*!
  * @brief This internal API is used to calculate the field data of sensor.
@@ -217,7 +168,7 @@
  *
  *  @return int8_t result of the field data from sensor.
  */
-static int8_t read_field_data(struct bme680_field_data *data, struct bme680_dev *dev);
+ int8_t read_field_data(struct bme680_field_data *data, struct bme680_dev *dev);
 
 /*!
  * @brief This internal API is used to set the memory page
@@ -235,7 +186,7 @@
  * @return Result of API execution status
  * @retval zero -> Success / +ve value -> Warning / -ve value -> Error
  */
-static int8_t set_mem_page(uint8_t reg_addr, struct bme680_dev *dev);
+ int8_t set_mem_page(uint8_t reg_addr, struct bme680_dev *dev);
 
 /*!
  * @brief This internal API is used to get the memory page based
@@ -252,7 +203,7 @@
  * @return Result of API execution status
  * @retval zero -> Success / +ve value -> Warning / -ve value -> Error
  */
-static int8_t get_mem_page(struct bme680_dev *dev);
+ int8_t get_mem_page(struct bme680_dev *dev);
 
 /*!
  * @brief This internal API is used to validate the device pointer for
@@ -263,7 +214,7 @@
  * @return Result of API execution status
  * @retval zero -> Success / +ve value -> Warning / -ve value -> Error
  */
-static int8_t null_ptr_check(const struct bme680_dev *dev);
+ int8_t null_ptr_check(const struct bme680_dev *dev);
 
 /*!
  * @brief This internal API is used to check the boundary
@@ -277,7 +228,7 @@
  * @return Result of API execution status
  * @retval zero -> Success / +ve value -> Warning / -ve value -> Error
  */
-static int8_t boundary_check(uint8_t *value, uint8_t min, uint8_t max, struct bme680_dev *dev);
+ int8_t boundary_check(uint8_t *value, uint8_t min, uint8_t max, struct bme680_dev *dev);
 
 /****************** Global Function Definitions *******************************/
 /*!
@@ -318,18 +269,8 @@
 
 	/* Check for null pointer in the device structure*/
 	rslt = null_ptr_check(dev);
-	if (rslt == BME680_OK) {
-		if (dev->intf == BME680_SPI_INTF) {
-			/* Set the memory page */
-			rslt = set_mem_page(reg_addr, dev);
-			if (rslt == BME680_OK)
-				reg_addr = reg_addr | BME680_SPI_RD_MSK;
-		}
-		dev->com_rslt = dev->read(dev->dev_id, reg_addr, reg_data, len);
-		if (dev->com_rslt != 0)
-			rslt = BME680_E_COM_FAIL;
-	}
-
+  parseCSv();
+  rslt = BME680_OK;
 	return rslt;
 }
 
@@ -725,18 +666,18 @@
 /*!
  * @brief This internal API is used to read the calibrated data from the sensor.
  */
-static int8_t get_calib_data(struct bme680_dev *dev)
+int8_t get_calib_data(struct bme680_dev *dev)
 {
 	int8_t rslt;
-	uint8_t coeff_array[BME680_COEFF_SIZE] = { 0 };
+	//uint8_t coeff_array[BME680_COEFF_SIZE] = { 0 };
 	uint8_t temp_var = 0; /* Temporary variable */
 
 	/* Check for null pointer in the device structure*/
 	rslt = null_ptr_check(dev);
-	if (rslt == BME680_OK) {
+	if (1/*rslt == BME680_OK*/) {
 		rslt = bme680_get_regs(BME680_COEFF_ADDR1, coeff_array, BME680_COEFF_ADDR1_LEN, dev);
 		/* Append the second half in the same array */
-		if (rslt == BME680_OK)
+		if (1/*rslt == BME680_OK*/)
 			rslt = bme680_get_regs(BME680_COEFF_ADDR2, &coeff_array[BME680_COEFF_ADDR1_LEN]
 			, BME680_COEFF_ADDR2_LEN, dev);
 
@@ -804,7 +745,7 @@
 /*!
  * @brief This internal API is used to set the gas configuration of the sensor.
  */
-static int8_t set_gas_config(struct bme680_dev *dev)
+ int8_t set_gas_config(struct bme680_dev *dev)
 {
 	int8_t rslt;
 
@@ -836,7 +777,7 @@
  * @note heatr_temp and heatr_dur values are currently register data
  * and not the actual values set
  */
-static int8_t get_gas_config(struct bme680_dev *dev)
+ int8_t get_gas_config(struct bme680_dev *dev)
 {
 	int8_t rslt;
 	/* starting address of the register array for burst read*/
@@ -868,169 +809,14 @@
 	return rslt;
 }
 
-#ifndef BME680_FLOAT_POINT_COMPENSATION
-
-/*!
- * @brief This internal API is used to calculate the temperature value.
- */
-static int16_t calc_temperature(uint32_t temp_adc, struct bme680_dev *dev)
-{
-	int64_t var1;
-	int64_t var2;
-	int64_t var3;
-	int16_t calc_temp;
-
-	var1 = ((int32_t) temp_adc >> 3) - ((int32_t) dev->calib.par_t1 << 1);
-	var2 = (var1 * (int32_t) dev->calib.par_t2) >> 11;
-	var3 = ((var1 >> 1) * (var1 >> 1)) >> 12;
-	var3 = ((var3) * ((int32_t) dev->calib.par_t3 << 4)) >> 14;
-	dev->calib.t_fine = (int32_t) (var2 + var3);
-	calc_temp = (int16_t) (((dev->calib.t_fine * 5) + 128) >> 8);
-
-	return calc_temp;
-}
-
-/*!
- * @brief This internal API is used to calculate the pressure value.
- */
-static uint32_t calc_pressure(uint32_t pres_adc, const struct bme680_dev *dev)
-{
-	int32_t var1;
-	int32_t var2;
-	int32_t var3;
-	int32_t pressure_comp;
-
-	var1 = (((int32_t)dev->calib.t_fine) >> 1) - 64000;
-	var2 = ((((var1 >> 2) * (var1 >> 2)) >> 11) *
-		(int32_t)dev->calib.par_p6) >> 2;
-	var2 = var2 + ((var1 * (int32_t)dev->calib.par_p5) << 1);
-	var2 = (var2 >> 2) + ((int32_t)dev->calib.par_p4 << 16);
-	var1 = (((((var1 >> 2) * (var1 >> 2)) >> 13) *
-		((int32_t)dev->calib.par_p3 << 5)) >> 3) +
-		(((int32_t)dev->calib.par_p2 * var1) >> 1);
-	var1 = var1 >> 18;
-	var1 = ((32768 + var1) * (int32_t)dev->calib.par_p1) >> 15;
-	pressure_comp = 1048576 - pres_adc;
-	pressure_comp = (int32_t)((pressure_comp - (var2 >> 12)) * ((uint32_t)3125));
-	if (pressure_comp >= BME680_MAX_OVERFLOW_VAL)
-		pressure_comp = ((pressure_comp / var1) << 1);
-	else
-		pressure_comp = ((pressure_comp << 1) / var1);
-	var1 = ((int32_t)dev->calib.par_p9 * (int32_t)(((pressure_comp >> 3) *
-		(pressure_comp >> 3)) >> 13)) >> 12;
-	var2 = ((int32_t)(pressure_comp >> 2) *
-		(int32_t)dev->calib.par_p8) >> 13;
-	var3 = ((int32_t)(pressure_comp >> 8) * (int32_t)(pressure_comp >> 8) *
-		(int32_t)(pressure_comp >> 8) *
-		(int32_t)dev->calib.par_p10) >> 17;
-
-	pressure_comp = (int32_t)(pressure_comp) + ((var1 + var2 + var3 +
-		((int32_t)dev->calib.par_p7 << 7)) >> 4);
-
-	return (uint32_t)pressure_comp;
-
-}
-
-/*!
- * @brief This internal API is used to calculate the humidity value.
- */
-static uint32_t calc_humidity(uint16_t hum_adc, const struct bme680_dev *dev)
-{
-	int32_t var1;
-	int32_t var2;
-	int32_t var3;
-	int32_t var4;
-	int32_t var5;
-	int32_t var6;
-	int32_t temp_scaled;
-	int32_t calc_hum;
-
-	temp_scaled = (((int32_t) dev->calib.t_fine * 5) + 128) >> 8;
-	var1 = (int32_t) (hum_adc - ((int32_t) ((int32_t) dev->calib.par_h1 * 16)))
-		- (((temp_scaled * (int32_t) dev->calib.par_h3) / ((int32_t) 100)) >> 1);
-	var2 = ((int32_t) dev->calib.par_h2
-		* (((temp_scaled * (int32_t) dev->calib.par_h4) / ((int32_t) 100))
-			+ (((temp_scaled * ((temp_scaled * (int32_t) dev->calib.par_h5) / ((int32_t) 100))) >> 6)
-				/ ((int32_t) 100)) + (int32_t) (1 << 14))) >> 10;
-	var3 = var1 * var2;
-	var4 = (int32_t) dev->calib.par_h6 << 7;
-	var4 = ((var4) + ((temp_scaled * (int32_t) dev->calib.par_h7) / ((int32_t) 100))) >> 4;
-	var5 = ((var3 >> 14) * (var3 >> 14)) >> 10;
-	var6 = (var4 * var5) >> 1;
-	calc_hum = (((var3 + var6) >> 10) * ((int32_t) 1000)) >> 12;
-
-	if (calc_hum > 100000) /* Cap at 100%rH */
-		calc_hum = 100000;
-	else if (calc_hum < 0)
-		calc_hum = 0;
-
-	return (uint32_t) calc_hum;
-}
-
-/*!
- * @brief This internal API is used to calculate the Gas Resistance value.
- */
-static uint32_t calc_gas_resistance(uint16_t gas_res_adc, uint8_t gas_range, const struct bme680_dev *dev)
-{
-	int64_t var1;
-	uint64_t var2;
-	int64_t var3;
-	uint32_t calc_gas_res;
-	/**Look up table 1 for the possible gas range values */
-	uint32_t lookupTable1[16] = { UINT32_C(2147483647), UINT32_C(2147483647), UINT32_C(2147483647), UINT32_C(2147483647),
-		UINT32_C(2147483647), UINT32_C(2126008810), UINT32_C(2147483647), UINT32_C(2130303777),
-		UINT32_C(2147483647), UINT32_C(2147483647), UINT32_C(2143188679), UINT32_C(2136746228),
-		UINT32_C(2147483647), UINT32_C(2126008810), UINT32_C(2147483647), UINT32_C(2147483647) };
-	/**Look up table 2 for the possible gas range values */
-	uint32_t lookupTable2[16] = { UINT32_C(4096000000), UINT32_C(2048000000), UINT32_C(1024000000), UINT32_C(512000000),
-		UINT32_C(255744255), UINT32_C(127110228), UINT32_C(64000000), UINT32_C(32258064), UINT32_C(16016016),
-		UINT32_C(8000000), UINT32_C(4000000), UINT32_C(2000000), UINT32_C(1000000), UINT32_C(500000),
-		UINT32_C(250000), UINT32_C(125000) };
-
-	var1 = (int64_t) ((1340 + (5 * (int64_t) dev->calib.range_sw_err)) *
-		((int64_t) lookupTable1[gas_range])) >> 16;
-	var2 = (((int64_t) ((int64_t) gas_res_adc << 15) - (int64_t) (16777216)) + var1);
-	var3 = (((int64_t) lookupTable2[gas_range] * (int64_t) var1) >> 9);
-	calc_gas_res = (uint32_t) ((var3 + ((int64_t) var2 >> 1)) / (int64_t) var2);
-
-	return calc_gas_res;
-}
-
-/*!
- * @brief This internal API is used to calculate the Heat Resistance value.
- */
-static uint8_t calc_heater_res(uint16_t temp, const struct bme680_dev *dev)
-{
-	uint8_t heatr_res;
-	int32_t var1;
-	int32_t var2;
-	int32_t var3;
-	int32_t var4;
-	int32_t var5;
-	int32_t heatr_res_x100;
 
-	if (temp > 400) /* Cap temperature */
-		temp = 400;
-
-	var1 = (((int32_t) dev->amb_temp * dev->calib.par_gh3) / 1000) * 256;
-	var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10);
-	var3 = var1 + (var2 / 2);
-	var4 = (var3 / (dev->calib.res_heat_range + 4));
-	var5 = (131 * dev->calib.res_heat_val) + 65536;
-	heatr_res_x100 = (int32_t) (((var4 / var5) - 250) * 34);
-	heatr_res = (uint8_t) ((heatr_res_x100 + 50) / 100);
-
-	return heatr_res;
-}
-
-#else
 
 
 /*!
  * @brief This internal API is used to calculate the
  * temperature value in float format
  */
-static float calc_temperature(uint32_t temp_adc, struct bme680_dev *dev)
+ float calc_temperature(uint32_t temp_adc, struct bme680_dev *dev)
 {
 	float var1 = 0;
 	float var2 = 0;
@@ -1058,7 +844,7 @@
  * @brief This internal API is used to calculate the
  * pressure value in float format
  */
-static float calc_pressure(uint32_t pres_adc, const struct bme680_dev *dev)
+ float calc_pressure(uint32_t pres_adc, const struct bme680_dev *dev)
 {
 	float var1 = 0;
 	float var2 = 0;
@@ -1093,7 +879,7 @@
  * @brief This internal API is used to calculate the
  * humidity value in float format
  */
-static float calc_humidity(uint16_t hum_adc, const struct bme680_dev *dev)
+ float calc_humidity(uint16_t hum_adc, const struct bme680_dev *dev)
 {
 	float calc_hum = 0;
 	float var1 = 0;
@@ -1129,7 +915,7 @@
  * @brief This internal API is used to calculate the
  * gas resistance value in float format
  */
-static float calc_gas_resistance(uint16_t gas_res_adc, uint8_t gas_range, const struct bme680_dev *dev)
+ float calc_gas_resistance(uint16_t gas_res_adc, uint8_t gas_range, const struct bme680_dev *dev)
 {
 	float calc_gas_res;
 	float var1 = 0;
@@ -1157,7 +943,7 @@
  * @brief This internal API is used to calculate the
  * heater resistance value in float format
  */
-static float calc_heater_res(uint16_t temp, const struct bme680_dev *dev)
+ float calc_heater_res(uint16_t temp, const struct bme680_dev *dev)
 {
 	float var1 = 0;
 	float var2 = 0;
@@ -1180,12 +966,12 @@
 	return res_heat;
 }
 
-#endif
+
 
 /*!
  * @brief This internal API is used to calculate the Heat duration value.
  */
-static uint8_t calc_heater_dur(uint16_t dur)
+ uint8_t calc_heater_dur(uint16_t dur)
 {
 	uint8_t factor = 0;
 	uint8_t durval;
@@ -1206,7 +992,7 @@
 /*!
  * @brief This internal API is used to calculate the field data of sensor.
  */
-static int8_t read_field_data(struct bme680_field_data *data, struct bme680_dev *dev)
+ int8_t read_field_data(struct bme680_field_data *data, struct bme680_dev *dev)
 {
 	int8_t rslt;
 	uint8_t buff[BME680_FIELD_LENGTH] = { 0 };
@@ -1262,7 +1048,7 @@
 /*!
  * @brief This internal API is used to set the memory page based on register address.
  */
-static int8_t set_mem_page(uint8_t reg_addr, struct bme680_dev *dev)
+ int8_t set_mem_page(uint8_t reg_addr, struct bme680_dev *dev)
 {
 	int8_t rslt;
 	uint8_t reg;
@@ -1301,7 +1087,7 @@
 /*!
  * @brief This internal API is used to get the memory page based on register address.
  */
-static int8_t get_mem_page(struct bme680_dev *dev)
+ int8_t get_mem_page(struct bme680_dev *dev)
 {
 	int8_t rslt;
 	uint8_t reg;
@@ -1323,7 +1109,7 @@
  * @brief This internal API is used to validate the boundary
  * conditions.
  */
-static int8_t boundary_check(uint8_t *value, uint8_t min, uint8_t max, struct bme680_dev *dev)
+ int8_t boundary_check(uint8_t *value, uint8_t min, uint8_t max, struct bme680_dev *dev)
 {
 	int8_t rslt = BME680_OK;
 
@@ -1351,7 +1137,7 @@
  * @brief This internal API is used to validate the device structure pointer for
  * null conditions.
  */
-static int8_t null_ptr_check(const struct bme680_dev *dev)
+ int8_t null_ptr_check(const struct bme680_dev *dev)
 {
 	int8_t rslt;
 
@@ -1365,3 +1151,51 @@
 
 	return rslt;
 }
+
+void parseCSv()
+{
+
+  coeff_array[0] = 0x00;
+  coeff_array[1] = 0x27;
+  coeff_array[2] = 0x66;
+  coeff_array[3] = 0x03;
+  coeff_array[4] = 0x0F;
+  coeff_array[5] = 0x7F;
+  coeff_array[6] = 0x89;
+  coeff_array[7] = 0x17;
+  coeff_array[8] = 0xD7;
+  coeff_array[9] = 0x58;
+  coeff_array[10] = 0xFF;
+  coeff_array[11] = 0x23;
+  coeff_array[12] = 0x14;
+  coeff_array[13] = 0x49;
+  coeff_array[14] = 0x00;
+  coeff_array[15] = 0x18;
+  coeff_array[16] = 0x1E;
+  coeff_array[17] = 0x00;
+  coeff_array[18] = 0x00;
+  coeff_array[19] = 0xF5;
+  coeff_array[20] = 0xFD;
+  coeff_array[21] = 0x76;
+  coeff_array[22] = 0xF2;
+  coeff_array[23] = 0x1E;
+  coeff_array[24] = 0x02;
+  coeff_array[25] = 0x40;
+  coeff_array[26] = 0x6F;
+  coeff_array[27] = 0x29;
+  coeff_array[28] = 0x00;
+  coeff_array[29] = 0x2D;
+  coeff_array[30] = 0x14;
+  coeff_array[31] = 0x78;
+  coeff_array[32] = 0x9C;
+  coeff_array[33] = 0xE1;
+  coeff_array[34] = 0x65;
+  coeff_array[35] = 0xFE;
+  coeff_array[36] = 0xF1;
+  coeff_array[37] = 0xE0;
+  coeff_array[38] = 0x12;
+  coeff_array[39] = 0x6B;
+  coeff_array[40] = 0x00;
+
+  
+}
